From: Stephen Farrell <stephen.farrell@cs.tcd.ie>
Date: Wed, 11 Oct 2023 22:40:18 +0100
Subject: placeholder code for wolfssl retry_configs tracing

---
 docs/ECH.md        |  1 +
 lib/vtls/wolfssl.c | 29 +++++++++++++++++++++++++++++
 2 files changed, 30 insertions(+)

diff --git a/docs/ECH.md b/docs/ECH.md
index f6e2965..acf59ea 100644
--- a/docs/ECH.md
+++ b/docs/ECH.md
@@ -140,6 +140,7 @@ the verbose output, e.g.:
 ```
 
 At that point, you could copy the base64 encoded value above and try again.
+For now, this only works for the openssl and boringssl builds.
 
 ## Default settings
 
diff --git a/lib/vtls/wolfssl.c b/lib/vtls/wolfssl.c
index 7bdb835..8bece3f 100644
--- a/lib/vtls/wolfssl.c
+++ b/lib/vtls/wolfssl.c
@@ -74,6 +74,10 @@
 #include "curl_memory.h"
 #include "memdebug.h"
 
+#ifdef USE_ECH
+# include "curl_base64.h"
+#endif /* USE_ECH */
+
 /* KEEP_PEER_CERT is a product of the presence of build time symbol
    OPENSSL_EXTRA without NO_CERTS, depending on the version. KEEP_PEER_CERT is
    in wolfSSL's settings.h, and the latter two are build time symbols in
@@ -914,6 +918,31 @@ wolfssl_connect_step2(struct Curl_cfilter *cf, struct Curl_easy *data)
                     "continuing anyway");
       }
     }
+#endif
+#ifdef USE_ECH
+    else if(-1 == detail) {
+      /* try access a retry_config ECHConfigList for tracing */
+      byte echConfigs[1000];
+      word32 echConfigsLen = 1000;
+      int rv = 0;
+
+      /* this currently doesn't produce the retry_configs */
+      rv = wolfSSL_GetEchConfigs(backend->handle, echConfigs,
+                                 &echConfigsLen);
+      if(rv != WOLFSSL_SUCCESS) {
+        infof(data, "Failed to get ECHConfigs");
+      }
+      else {
+        char *b64str = NULL;
+        size_t blen = 0;
+
+        rv = Curl_base64_encode((const char *)echConfigs, echConfigsLen,
+                                &b64str, &blen);
+        if(!rv && b64str)
+          infof(data, "ECH: (not yet) retry_configs %s", b64str);
+        free(b64str);
+      }
+    }
 #endif
     else if(backend->io_result == CURLE_AGAIN) {
       return CURLE_OK;
