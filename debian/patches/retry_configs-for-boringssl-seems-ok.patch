From: Stephen Farrell <stephen.farrell@cs.tcd.ie>
Date: Wed, 11 Oct 2023 21:42:28 +0100
Subject: retry_configs for boringssl seems ok

---
 docs/ECH.md        | 18 +++++++++++++++---
 lib/vtls/openssl.c | 28 +++++++++++++++-------------
 2 files changed, 30 insertions(+), 16 deletions(-)

diff --git a/docs/ECH.md b/docs/ECH.md
index a9bec26..f6e2965 100644
--- a/docs/ECH.md
+++ b/docs/ECH.md
@@ -127,6 +127,20 @@ There is a reason to keep this command line option - for use before publishing
 the ECHConfigList in the DNS (e.g. as per the Internet-draft
 [A well-known URI for publishing ECHConfigList values](https://datatracker.ietf.org/doc/draft-ietf-tls-wkech/).
 
+If you do use a wrong ECHConfigList value, then the server might return a
+good value, via the ``retry_configs`` mechanism. You can see that value in
+the verbose output, e.g.:
+
+```bash
+    LD_LIBRARY_PATH=$HOME/code/openssl ./src/curl -vvv --ech ecl:AED+DQA8yAAgACDRMQo+qYNsNRNj+vfuQfFIkrrUFmM4vogucxKj/4nzYgAEAAEAAQANY292ZXIuZGVmby5pZQAA https://defo.ie/ech-check.php
+    ...
+* ECH: retry_configs AQD+DQA8DAAgACBvYqJy+Hgk33wh/ZLBzKSPgwxeop7gvojQzfASq7zeZQAEAAEAAQANY292ZXIuZGVmby5pZQAA/g0APEMAIAAgXkT5r4cYs8z19q5rdittyIX8gfQ3ENW4wj1fVoiJZBoABAABAAEADWNvdmVyLmRlZm8uaWUAAP4NADw2ACAAINXSE9EdXzEQIJZA7vpwCIQsWqsFohZARXChgPsnfI1kAAQAAQABAA1jb3Zlci5kZWZvLmllAAD+DQA8cQAgACASeiD5F+UoSnVoHvA2l1EifUVMFtbVZ76xwDqmMPraHQAEAAEAAQANY292ZXIuZGVmby5pZQAA
+* ECH: retry_configs for defo.ie from cover.defo.ie, 319
+    ...
+```
+
+At that point, you could copy the base64 encoded value above and try again.
+
 ## Default settings
 
 Curl has various ways to configure default settings, e.g. in ``$HOME/.curlrc``,
@@ -423,9 +437,7 @@ As of now we have not:
 - added support for using ``retry_config`` handling in the application - for a
   command line tool, one can just use ``dig`` (or ``kdig``) to get the HTTPS
   RR and pass the ECHConfigList from that on the command line, if needed
-- if we did add the above, we'd also need to do a better job on authenticating
-  the outer name
 
 Both our OpenSSL fork and boringssl have APIs for both controlling GREASE and
-accessing ``retry_configs``, it seems WolfSSL has neither.
+accessing and logging ``retry_configs``, it seems WolfSSL has neither.
 
diff --git a/lib/vtls/openssl.c b/lib/vtls/openssl.c
index 2cc170b..df9514c 100644
--- a/lib/vtls/openssl.c
+++ b/lib/vtls/openssl.c
@@ -3805,17 +3805,17 @@ static CURLcode ossl_connect_step1(struct Curl_cfilter *cf,
     unsigned char *ech_config = NULL;
     size_t ech_config_len = 0;
     char *outername = data->set.str[STRING_ECH_PUBLIC];
-    int rv, trying_ech_now = 0;
+    int trying_ech_now = 0;
 
     if(data->set.tls_ech == CURLECH_GREASE) {
-#ifdef OPENSSL_IS_BORINGSSL
+# ifdef OPENSSL_IS_BORINGSSL
       SSL_set_enable_ech_grease(backend->handle, 1);
-#else
+# else
       SSL_set_options(backend->handle, SSL_OP_ECH_GREASE);
-#endif
+# endif
     }
     if(data->set.tls_ech == CURLECH_CLA_CFG) {
-#ifdef OPENSSL_IS_BORINGSSL
+# ifdef OPENSSL_IS_BORINGSSL
       /* have to do base64 decode here for boring */
       const char *b64 = data->set.str[STRING_ECH_CONFIG];
 
@@ -3840,7 +3840,7 @@ static CURLcode ossl_connect_step1(struct Curl_cfilter *cf,
       }
       free(ech_config);
       trying_ech_now = 1;
-#else
+# else
       ech_config = (unsigned char *) data->set.str[STRING_ECH_CONFIG];
       if(!ech_config) {
         infof(data, "ECH: ECHConfig from command line empty");
@@ -3856,7 +3856,7 @@ static CURLcode ossl_connect_step1(struct Curl_cfilter *cf,
       }
       else
         trying_ech_now = 1;
-#endif
+# endif
     }
     else {
       struct Curl_dns_entry *dns = NULL;
@@ -3912,10 +3912,10 @@ static CURLcode ossl_connect_step1(struct Curl_cfilter *cf,
     if(trying_ech_now && outername) {
       infof(data, "ECH: inner: '%s', outer: '%s'",
             hostname, outername);
-      rv = SSL_ech_set_server_names(backend->handle,
+      result = SSL_ech_set_server_names(backend->handle,
                                     hostname, outername,
                                     0 /* do send outer */);
-      if(rv != 1) {
+      if(result != 1) {
         infof(data, "ECH: rv failed to set server name(s) %d [ERROR]", rv);
         return CURLE_SSL_CONNECT_ERROR;
       }
@@ -4095,7 +4095,7 @@ static CURLcode ossl_connect_step2(struct Curl_cfilter *cf,
 # ifndef OPENSSL_IS_BORINGSSL
               (reason == SSL_R_ECH_REQUIRED)) {
 # else
-              (reason == SSL_AD_ECH_REQUIRED)) {
+              (reason == SSL_R_ECH_REJECTED)) {
 # endif
         /* If we have retry configs, then trace those out */
         size_t rcl = 0;
@@ -4114,7 +4114,7 @@ static CURLcode ossl_connect_step2(struct Curl_cfilter *cf,
         SSL_get0_ech_name_override(backend->handle, &outer, &out_name_len);
         SSL_get0_ech_retry_configs(backend->handle, &rcs, &rcl);
         inner = connssl->hostname;
-        rv = rcl;
+        rv = (int)rcl;
 # endif
 
         if(rv && rcs) {
@@ -4129,11 +4129,13 @@ static CURLcode ossl_connect_step2(struct Curl_cfilter *cf,
           free(b64str);
 # ifndef OPENSSL_IS_BORINGSSL
           rv = SSL_ech_get_status(backend->handle, &inner, &outer);
+          infof(data, "ECH: retry_configs for %s from %s, %d %d",
+                inner ? inner : "NULL", outer ? outer : "NULL", reason, rv);
 #else
           rv = SSL_ech_accepted(backend->handle);
-#endif
           infof(data, "ECH: retry_configs for %s from %s, %d",
-                inner ? inner : "NULL", outer ? outer : "NULL", rv);
+                inner ? inner : "NULL", outer ? outer : "NULL", reason);
+#endif
         }
         else
           infof(data, "ECH: no retry_configs (rv = %d)", rv);
